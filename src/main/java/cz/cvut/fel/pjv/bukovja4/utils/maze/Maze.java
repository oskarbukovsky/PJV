package cz.cvut.fel.pjv.bukovja4.utils.maze;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Stack;

import cz.cvut.fel.pjv.bukovja4.engine.elements.BaseElement;
import cz.cvut.fel.pjv.bukovja4.engine.elements.ElementTypes;
import cz.cvut.fel.pjv.bukovja4.engine.elements.specific.*;
import cz.cvut.fel.pjv.bukovja4.engine.logic.GameState;
import cz.cvut.fel.pjv.bukovja4.utils.engine.*;
import cz.cvut.fel.pjv.bukovja4.utils.engine.dim.Dim2d;
import cz.cvut.fel.pjv.bukovja4.utils.logging.LOG;

import static cz.cvut.fel.pjv.bukovja4.engine.elements.ElementFactory.Factory2d;

/**
 * Maze generation and management class.
 * This class is responsible for generating a maze using a depth-first search
 * algorithm.
 * It also handles the initialization of maze elements and their placement in
 * the maze grid.
 */
public class Maze {
    @SuppressWarnings("unused")
    private static int seed;
    private static int width;
    private static int height;
    private static ArrayList<BaseElement<?>> elements;

    /**
     * Prepares the maze with the given seed, width, and height.
     * Initializes the maze grid and sets the seed for random generation.
     *
     * @param seed   The seed for random generation.
     * @param width  The width of the maze.
     * @param height The height of the maze.
     */
    public static void prepareMaze(int seed, int width, int height) {
        Maze.seed = seed;
        Maze.width = width;
        Maze.height = height;
        GameState.maze = new MazeCell[width][height];
        LOG.warn("Prepare maze with seed: " + seed);
    }

    /**
     * Generates a maze using depth-first search algorithm.
     * The maze is generated by carving paths through a grid of cells.
     *
     * @param elements The list of elements to be placed in the maze.
     * @param startX   The starting X coordinate for the player.
     * @param startY   The starting Y coordinate for the player.
     * @param goalX    The goal X coordinate for the maze.
     * @param goalY    The goal Y coordinate for the maze.
     */
    public static void generateMaze(ArrayList<BaseElement<?>> elements, int startX, int startY, int goalX, int goalY) {
        Maze.elements = elements;
        LOG.warn("Generating maze");
        Random rand = new Random(seed);

        // Initialize all cells as walls
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                GameState.maze[x][y] = new MazeCell(CellTypes.WALL, null);
            }
        }

        int[][] directions = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };

        Stack<int[]> stack = new Stack<>();

        GameState.maze[startX][startY] = new MazeCell(CellTypes.GROUND, null);
        stack.push(new int[] { startX, startY });

        boolean[][] visited = new boolean[width][height];
        visited[startX][startY] = true;

        for (int x = 0; x < width; x++) {
            visited[x][0] = true;
            visited[x][height - 1] = true;
        }
        for (int y = 0; y < height; y++) {
            visited[0][y] = true;
            visited[width - 1][y] = true;
        }

        boolean goalReached = false;

        while (!stack.isEmpty()) {
            int[] current = stack.peek();
            int x = current[0];
            int y = current[1];

            List<int[]> neighbors = new ArrayList<>();
            for (int[] dir : directions) {
                int nx = x + dir[0] * 2; // Move 2 cells in direction
                int ny = y + dir[1] * 2;

                if (nx >= 1 && nx < width - 1 && ny >= 1 && ny < height - 1 && !visited[nx][ny]) {
                    neighbors.add(new int[] { nx, ny, x + dir[0], y + dir[1] });
                }
            }

            if (!neighbors.isEmpty()) {
                int[] next = neighbors.get(rand.nextInt(neighbors.size()));
                int nx = next[0];
                int ny = next[1];
                int wx = next[2];
                int wy = next[3];

                GameState.maze[wx][wy] = new MazeCell(CellTypes.GROUND, null);
                GameState.maze[nx][ny] = new MazeCell(CellTypes.GROUND, null);

                visited[wx][wy] = true;
                visited[nx][ny] = true;

                stack.push(new int[] { nx, ny });

                if (nx == goalX && ny == goalY) {
                    goalReached = true;
                }
            } else {
                stack.pop();
            }
        }

        if (!goalReached) {
            int closestX = -1, closestY = -1;
            int minDistance = Integer.MAX_VALUE;

            for (int x = 1; x < width - 1; x++) {
                for (int y = 1; y < height - 1; y++) {
                    if (GameState.maze[x][y].getCellType() == CellTypes.GROUND) {
                        int distance = Math.abs(x - goalX) + Math.abs(y - goalY);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestX = x;
                            closestY = y;
                        }
                    }
                }
            }

            // Carve a path from the closest ground cell to the goal
            int x = closestX, y = closestY;
            while (x != goalX || y != goalY) {
                if (rand.nextBoolean() && x != goalX) {
                    int dx = (x < goalX) ? 1 : -1;
                    x += dx;
                } else if (y != goalY) {
                    int dy = (y < goalY) ? 1 : -1;
                    y += dy;
                }
                GameState.maze[x][y] = new MazeCell(CellTypes.GROUND, null);
            }
        }

        // Make sure start and goal are properly set
        GameState.maze[startX][startY] = new MazeCell(CellTypes.PLAYER, null);
        GameState.maze[goalX][goalY] = new MazeCell(CellTypes.GOAL, null);
    }

    public static void finishMaze(float scale) throws Throwable {
        StringBuilder sb = new StringBuilder();
        for (int x = 0; x < Maze.width; x++) {
            for (int y = 0; y < Maze.height; y++) {
                Box<Dim2d> bounds = new Box<>(
                        new Pos<>(x * scale * 20, y * scale * 20),
                        new Pos<>((x + 1) * scale * 20, (y + 1) * scale * 20));
                switch (GameState.maze[x][y].getCellType()) {
                    case WALL -> {
                        Wall<?> element = (Wall<?>) Factory2d
                                .create(ElementTypes.WALL, bounds);
                        GameState.maze[x][y].setElement(element);
                        element.dispatchInit(scale);
                        Maze.elements.add(element);
                        sb.append("â–ˆ");
                    }
                    case GROUND -> {
                        Ground<?> element = (Ground<?>) Factory2d
                                .create(ElementTypes.GROUND, bounds);
                        GameState.maze[x][y].setElement(element);
                        element.dispatchInit(scale);
                        Maze.elements.add(element);
                        sb.append(" ");
                    }
                    case PLAYER -> {
                        Player<?> element = (Player<?>) Factory2d
                                .create(ElementTypes.PLAYER, bounds);
                        GameState.maze[x][y].setElement(element);
                        element.dispatchInit(scale);
                        Maze.elements.add(element);
                        GameState.playerPos[0] = x;
                        GameState.playerPos[1] = y;
                        sb.append("P");
                    }
                    case GOAL -> {
                        Goal<?> element = (Goal<?>) Factory2d
                                .create(ElementTypes.GOAL, bounds);
                        GameState.maze[x][y].setElement(element);
                        element.dispatchInit(scale);
                        Maze.elements.add(element);
                        sb.append("G");
                    }
                }
            }
            sb.append("\n");
        }
        // System.out.println(sb.toString());
    }
}
